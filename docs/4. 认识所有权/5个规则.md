### 1. 所有权 (Ownership)

这是 Rust 内存管理的基础，规定了值与变量的根本关系。

- **规则 1：** 每个值都有一个被称为其**所有者 (owner)** 的变量。
- **规则 2：** 值在任何时刻都**只能有一个**所有者。
- **规则 3：** 当所有者（变量）离开作用域时，其拥有的值将被**销毁 (drop)**，内存被自动释放。

---

### 2. 所有权转移 (Move)

这是“规则 2”的直接体现，发生在数据从一个所有者“转移”给另一个所有者时。

- **规则 1：** 对于没有实现 `Copy` Trait 的类型（如 `String`, `Vec<T>`, `Box<T>`），**赋值操作**或**函数传参**会导致所有权“移动”(Move)。
- **规则 2：** 所有权转移后，原来的变量将**立即失效**，不能再被使用，以防止“二次释放”等内存安全问题。

---

### 3. 不可变借用 / 共享引用 (`&T`)

用于在不转移所有权的情况下，安全地“读取”数据。

- **规则 1：** **不获取**值的所有权，只是临时“借用”其访问权限。
- **规则 2：** 通过不可变引用，**不能修改**其指向的数据（只读）。
- **规则 3：** 在同一作用域内，可以同时存在**任意多个**对同一数据的不可变引用。

---

### 4. 可变借用 / 独占引用 (`&mut T`)

用于在不转移所有权的情况下，安全地“修改”数据。

- **规则 1：** 同样**不获取**所有权，只是临时借用“可修改”的权限。
- **规则 2：** 通过可变引用，**可以修改**其指向的数据。
- **规则 3 (独占规则)：** 在同一作用域内，对同一数据，**只能存在一个**可变引用。
- **规则 4 (混合规则)：** 当一个可变引用存在时，**不能存在任何**不可变引用。此规则是“独占”的延伸，确保在修改数据时，没有任何地方在读取它，从而在编译期杜绝数据竞争。

---

### 5. 生命周期 (Lifetimes)

这是借用系统的安全卫士，确保所有引用都是有效的。

- **黄金规则：** **引用的生命周期（作用域）不能长于它所指向的数据的生命周期。**
- **编译器角色：** 生命周期是编译器用来检查并确保所有引用都永远不会成为“悬垂引用”的工具。
- **程序员角色：** 大多数情况下编译器会自动推断生命周期（生命周期省略）。只有在函数的参数和返回值包含引用等复杂情况下，才需要程序员手动标注生命周期参数（如 `<'a>`），以帮助编译器消除歧义。

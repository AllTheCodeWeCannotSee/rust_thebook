### **`enum` (枚举)**

- **核心定义**: 一种自定义数据类型，允许你定义一个值可能属于的一系列“可能性”。
- **强大之处**: Rust 的 `enum` 不仅仅是标签，它的每个“变体”都可以携带不同类型和数量的数据。
- **与 `struct` 的区别**: `struct` 将多个字段组合成一个整体（所有字段同时存在）；`enum` 则是多选一（只有一个变体在某一时刻是有效的）。

---

### **`variants` (变体)**

- **定义**: `enum` 中定义的每一种可能性，就是它的一个变体。
- **形式**:
  - 无数据，仅作标签：`Quit`
  - 包含一个或多个匿名数据（类似元组）：`Write(String)` 或 `ChangeColor(i32, i32, i32)`
  - 包含命名字段（类似结构体）：`Move { x: i32, y: i32 }`
- **调用**: 带数据的变体在使用时如同一个函数或构造器，例如 `MyEnum::Write(String::from("hello"))`。

---

### **如何表示一个值是“几个可能性中的一个”？**

- **答案**: 使用 **`enum`**。
- **方法**: 将每一种“可能性”定义为 `enum` 的一个 `variant`（变体）。这样，持有该 `enum` 类型变量的值就被编译器限制在这些可能性之中，无法取其他值。

---

### **`Option<T>` 与 空值 (Null)**

- **问题来源 (空值)**: `null` 是“十亿美元的错误”，它在运行时出现，会导致程序崩溃，且无法在编译时被发现。
- **Rust 的解决方案 (`Option<T>`)**: 一个 `enum`，它在**类型系统**层面解决了空值问题。
  - 定义: `enum Option<T> { Some(T), None }`
  - `Some(T)`: 表示“有值”，并将值 `T` 包裹其中。
  - `None`: 表示“无值”。
- **安全性保障**: `T` 和 `Option<T>` 是两种**完全不同**的类型。Rust 编译器会**强制**你在使用 `Option<T>` 之前，必须通过 `match` 等工具处理 `None` 的情况，才能安全地取出 `Some` 里的值。这将潜在的运行时错误转变成了**编译时错误**。

---

### **`match`**

- **核心功能**: Rust 中最强大、最主要的**模式匹配 (Pattern Matching)** 工具。
- **关键特性**: **穷尽性 (Exhaustiveness)**。编译器会检查并确保你处理了一个值所有可能存在的模式（特别是 `enum` 的所有变体），否则无法通过编译。
- **工作方式**: 将一个值与一系列模式进行比较，一旦找到匹配的模式，就执行对应的代码块。在匹配时，可以**解构**出值内部的数据并**绑定**到新变量。

---

### **通配模式和 `_` 占位符**

- **目的**: 当你使用 `match` 但不想列出所有可能的分支时，可以使用通配符来处理“所有其他情况”。
- **`_` 占位符**: 是一个特殊的通配符，它会匹配任何值，但**不会**将该值绑定到任何变量。它告诉编译器：“我确实考虑了其他所有情况，但我对它们的值不感兴趣，请统一处理或直接忽略。”
- **示例**:
  ```rust
  match some_value {
      0 => println!("zero"),
      1 => println!("one"),
      _ => println!("anything else"), // 匹配所有其他数字
  }
  ```

---

### **`if let`**

- **定义**: `match` 的一种“语法糖”，更简洁。
- **适用场景**: 当你只关心**某一种**匹配模式，而想忽略所有其他模式时。
- **工作方式**: `if let <模式> = <表达式>`。如果表达式的值能够匹配该模式，就执行代码块，同时可以解构和绑定变量。如果不能匹配，则直接跳过代码块。
- **好处**: 避免了为了处理一种情况而写出带有 `_ => {}` 的冗长 `match` 语句。

---

### **`let else`**

- **定义**: 一个用于**解构和提前退出**的“卫兵”式语法。
- **适用场景**: 在函数或代码块开头，需要确保某个值符合特定模式（通常是解包 `Option` 或 `Result`），否则就无法继续执行。
- **工作方式**: `let <模式> = <表达式> else { <发散代码> };`。如果匹配成功，则将值绑定到变量并继续；如果匹配失败，则必须执行 `else` 块，而 `else` 块必须**发散**（即通过 `return`, `break`, `continue` 或 `panic!` 等方式提前退出）。
- **好处**: 让“快乐路径”（Happy Path）的代码不再需要层层嵌套，逻辑更扁平、更清晰。

---

### **总结：控制流程选择**

| 语法             | 核心用途                 | 处理对象                     | 关键特性                            |
| :--------------- | :----------------------- | :--------------------------- | :---------------------------------- |
| **`match`**      | 处理所有可能性           | 任何类型，尤其适合 `enum`    | **必须穷尽**，安全性最高            |
| **`if let`**     | 只处理一种你关心的可能性 | `enum` / `Option` / `Result` | **简洁**，忽略其他所有情况          |
| **`let...else`** | 保证值存在，否则提前退出 | `enum` / `Option` / `Result` | 简化卫兵代码，**`else` 块必须发散** |
| **`if...else`**  | 基于真/假条件进行分支    | **布尔值** (`true`/`false`)  | 基础的逻辑判断，不涉及模式匹配      |

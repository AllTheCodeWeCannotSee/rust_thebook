好的，这是根据我们刚才的对话为您生成的学习笔记。

#### 1\. Vector（向量）与借用规则

- **核心规则**：不能在拥有一个对 `Vec` 元素的不可变引用的同时，对 `Vec` 本身进行可变操作（如 `v.push()`）。
- **深层原因**：`v.push()` 可能会导致 `Vec` 重新分配内存（当容量不足时）。如果允许这种操作，原有的元素引用就会指向一块被释放的无效内存，成为“悬垂指针”。Rust 的借用检查器在编译时就防止了这种危险。
- **示例**：
  ```rust
  let mut v = vec![1, 2, 3];
  let first = &v[0]; // 不可变借用
  // v.push(4);      // 错误！这里尝试可变借用 v
  println!("{}", first);
  ```

#### 2\. String（字符串）的两种类型：`String` vs `&str`

- `&str` (字符串切片/字面量):
  - 是**不可变**的**借用**。
  - 通常指向硬编码在程序里或另一个 `String` 上的数据。
  - 不能直接修改，没有 `push_str` 等方法。
- `String`:
  - 是**可变**的、**拥有所有权**的类型。
  - 数据存储在堆上，可以动态增长。
  - 拥有 `push_str` 等修改自身的方法。

#### 3\. HashMap（哈希映射）与所有权

- `HashMap` 会**取得**其键和值的所有权。
- **移动 (Move)**: 当你将一个拥有所有权的值（如 `String`）插入 `HashMap` 后，该值的所有权就转移给了 `HashMap`，原变量会失效。
- **复制 (Copy)**: 当你插入一个实现了 `Copy` trait 的值（如 `i32`）时，`HashMap` 会存储该值的一个副本，原变量依然有效。

#### 4\. HashMap 的高级用法：`entry` API

- **核心功能**：高效地处理“键存在或不存在”的逻辑，避免手写 `if/else` 判断。
- **常用模式：单词计数**

  ```rust
  // 如果 word 不存在，插入 0 并返回对 0 的可变引用
  // 如果 word 已存在，直接返回对其值的可变引用
  let count = map.entry(word).or_insert(0);

  // *count 解引用，直接修改 map 中的值
  *count += 1;
  ```

- `entry(key).or_insert(value)` 是一个原子性的“有则不动，无则插入”操作。

#### 5\. 调试输出 `{:?}`

- `println!("{}", variable);` 使用 `Display` trait，用于提供给**最终用户**看的、美观的输出。
- `println!("{:?}", variable);` 使用 `Debug` trait，用于给**开发者**看的、用于**调试**的、能清晰展示其内部结构的输出。
- `{:#?}` 则是 `Debug` 的美化版本，会带上缩进和换行。

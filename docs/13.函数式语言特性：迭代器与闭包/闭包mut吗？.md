

一句话准则：
**如果闭包会“动手”修改它外面的东西，那么 `let` 后面就要加 `mut`。**

-----

### 判断方法

请看闭包的 `||` 后面，花括号 `{}` 里面的代码：

**1. 需要 `mut` 的情况：**

如果闭包**修改**了任何它捕获的外部变量 (比如调用 `.push()`, `+= 1`, 或者改变字段的值)，那么持有这个闭包的变量**必须**是 `mut`。

```rust
// 数据源本身必须是 mut
let mut some_data = vec![]; 

// 这个闭包修改了 some_data
let mut my_closure = || some_data.push(1);

// 因为闭包是“修改型”的，所以调用它时，持有它的变量 my_closure 就必须是 mut
my_closure(); 
```

**2. 不需要 `mut` 的情况：**

如果闭包只是**读取**或**查看**外部变量 (比如打印它 `println!`，或者进行计算后返回新值)，没有对外部变量进行任何修改，那么持有它的变量就**不需要** `mut`。

```rust
let some_data = vec![1, 2, 3];

// 这个闭包只是读取 some_data
let my_closure = || println!("{:?}", some_data);

// 因为闭包是“只读型”的，所以调用它时，持有它的变量 my_closure 不需要 mut
my_closure(); 
```

### 简单记忆法

您可以这样问自己：

“这个闭包被调用后，外面的世界会因为它而改变吗？”

  * **会改变** -\> `let mut a = || ... ;`
  * **不会改变** -\> `let a = || ... ;`